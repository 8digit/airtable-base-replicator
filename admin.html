<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Airtable Replicator â€” Admin</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .spinner { border: 3px solid #e5e7eb; border-top-color: #3b82f6; border-radius: 50%; width: 20px; height: 20px; animation: spin 0.6s linear infinite; display: inline-block; }
    @keyframes spin { to { transform: rotate(360deg); } }
  </style>
</head>
<body class="bg-gray-50 min-h-screen">
<div class="max-w-2xl mx-auto py-10 px-4">

  <h1 class="text-2xl font-bold text-gray-900 mb-1">Airtable Replicator â€” Admin</h1>
  <p class="text-gray-500 text-sm mb-8">Generate student install pages from your Airtable bases. No terminal needed.</p>

  <!-- Settings (saved to localStorage) -->
  <div class="bg-white rounded-lg border border-gray-200 p-6 mb-6">
    <h2 class="text-lg font-semibold text-gray-800 mb-4">Your Settings</h2>

    <div class="mb-4">
      <label class="block text-sm font-medium text-gray-700 mb-1" for="admin-key">Airtable Personal Access Token</label>
      <input type="password" id="admin-key" placeholder="patXXXXXXXXXXXXXXXX.XXXXXXX"
        class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
      <p class="text-xs text-gray-500 mt-1">Saved locally in your browser. Never sent anywhere except Airtable's API (via your proxy).</p>
    </div>

    <div class="mb-4">
      <label class="block text-sm font-medium text-gray-700 mb-1" for="admin-proxy">CORS Proxy URL</label>
      <input type="text" id="admin-proxy" placeholder="https://airtable-replicator-proxy.8digit.workers.dev"
        class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
      <p class="text-xs text-gray-500 mt-1">Your Cloudflare Worker URL. Saved for future visits.</p>
    </div>

    <hr class="my-4 border-gray-200">
    <p class="text-xs text-gray-400 uppercase font-semibold mb-3">GitHub Pages (for one-click deploy)</p>

    <div class="mb-4">
      <label class="block text-sm font-medium text-gray-700 mb-1" for="admin-gh-token">GitHub Token</label>
      <input type="password" id="admin-gh-token" placeholder="ghp_XXXXXXXXXXXXXXXXXXXX"
        class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
      <p class="text-xs text-gray-500 mt-1">
        A <a href="https://github.com/settings/tokens/new?scopes=repo&description=Airtable+Replicator+Deploy" target="_blank" class="text-blue-600 underline">GitHub Personal Access Token</a> with <code class="bg-gray-100 px-1 rounded">repo</code> scope. Saved locally.
      </p>
    </div>

    <div class="mb-4">
      <label class="block text-sm font-medium text-gray-700 mb-1" for="admin-gh-repo">GitHub Repo</label>
      <input type="text" id="admin-gh-repo" placeholder="8digit/airtable-base-replicator"
        class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
      <p class="text-xs text-gray-500 mt-1">Format: <code class="bg-gray-100 px-1 rounded">owner/repo-name</code>. Must have a <code class="bg-gray-100 px-1 rounded">gh-pages</code> branch.</p>
    </div>

    <button id="save-settings" class="text-sm text-blue-600 hover:text-blue-800 font-medium">Save settings</button>
    <span id="save-confirm" class="text-sm text-green-600 ml-2 hidden">Saved!</span>
  </div>

  <!-- Generate Form -->
  <div class="bg-white rounded-lg border border-gray-200 p-6 mb-6">
    <h2 class="text-lg font-semibold text-gray-800 mb-4">Generate Install Page</h2>

    <div class="mb-4">
      <label class="block text-sm font-medium text-gray-700 mb-1" for="gen-base">Base ID</label>
      <input type="text" id="gen-base" placeholder="appXXXXXXXXXXXXXX"
        class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
      <p class="text-xs text-gray-500 mt-1">Open your base in Airtable â†’ the ID is in the URL: airtable.com/<strong>appXXXXXX</strong>/...</p>
    </div>

    <div class="mb-4">
      <label class="block text-sm font-medium text-gray-700 mb-1" for="gen-name">Course / Base Name</label>
      <input type="text" id="gen-name" placeholder="AI Video+B-Roll Agent"
        class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
      <p class="text-xs text-gray-500 mt-1">This name appears in the student install page header and in the downloaded filename.</p>
    </div>

    <button id="generate-btn"
      class="w-full bg-blue-600 text-white py-2.5 px-4 rounded-md font-medium hover:bg-blue-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed">
      Fetch Schema & Generate HTML
    </button>
  </div>

  <!-- Status -->
  <div id="status-section" class="hidden mb-6">
    <div class="flex items-center gap-2 mb-3">
      <div id="status-spinner" class="spinner"></div>
      <span id="status-text" class="text-gray-700 text-sm">Fetching schema...</span>
    </div>
  </div>

  <!-- Schema Preview + Actions -->
  <div id="result-section" class="hidden">
    <div class="bg-green-50 border border-green-200 rounded-lg p-6 mb-4">
      <h2 class="text-green-800 text-lg font-semibold mb-2">Install page ready!</h2>
      <div id="schema-summary" class="text-green-700 text-sm mb-4"></div>

      <div class="flex gap-3 flex-wrap">
        <button id="deploy-btn"
          class="bg-blue-600 text-white py-2 px-4 rounded-md font-medium hover:bg-blue-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2">
          ðŸš€ Deploy to GitHub Pages
        </button>
        <button id="download-btn"
          class="bg-gray-200 text-gray-700 py-2 px-4 rounded-md font-medium hover:bg-gray-300 transition-colors">
          ðŸ’¾ Download HTML File
        </button>
      </div>
    </div>
  </div>

  <!-- Deploy Status -->
  <div id="deploy-status" class="hidden mb-6">
    <div class="flex items-center gap-2 mb-3">
      <div class="spinner"></div>
      <span id="deploy-status-text" class="text-gray-700 text-sm">Deploying to GitHub Pages...</span>
    </div>
  </div>

  <!-- Deploy Success â€” Student Link -->
  <div id="deploy-result" class="hidden mb-6">
    <div class="bg-blue-50 border border-blue-200 rounded-lg p-6">
      <h2 class="text-blue-800 text-lg font-semibold mb-2">ðŸŽ‰ Deployed!</h2>
      <p class="text-blue-700 text-sm mb-3">Share this link with your students:</p>
      <div class="flex items-center gap-2">
        <input type="text" id="student-link" readonly
          class="flex-1 px-3 py-2 bg-white border border-blue-300 rounded-md text-sm text-blue-800 font-mono">
        <button id="copy-link-btn"
          class="bg-blue-600 text-white py-2 px-4 rounded-md font-medium hover:bg-blue-700 transition-colors whitespace-nowrap">
          ðŸ“‹ Copy
        </button>
      </div>
      <p class="text-xs text-gray-500 mt-2">First deploy takes ~1 min to go live. Subsequent deploys are faster.</p>
    </div>
  </div>

  <!-- Error -->
  <div id="error-section" class="hidden mb-6 bg-red-50 border border-red-200 rounded-lg p-4">
    <p id="error-text" class="text-red-700 text-sm"></p>
  </div>

</div>

<script>
(function () {
  "use strict";

  // â”€â”€ Field type classifications (mirrors export-schema.js) â”€â”€
  const NON_CREATABLE_TYPES = new Set(["formula", "rollup", "multipleLookupValues", "count"]);
  const AUTO_SYSTEM_TYPES = new Set(["autoNumber", "createdTime", "lastModifiedTime", "createdBy", "lastModifiedBy"]);
  const LINK_TYPE = "multipleRecordLinks";

  // â”€â”€ LocalStorage persistence â”€â”€
  const keyEl = document.getElementById("admin-key");
  const proxyEl = document.getElementById("admin-proxy");
  const ghTokenEl = document.getElementById("admin-gh-token");
  const ghRepoEl = document.getElementById("admin-gh-repo");

  // Load saved settings
  keyEl.value = localStorage.getItem("atr_key") || "";
  proxyEl.value = localStorage.getItem("atr_proxy") || "";
  ghTokenEl.value = localStorage.getItem("atr_gh_token") || "";
  ghRepoEl.value = localStorage.getItem("atr_gh_repo") || "";

  document.getElementById("save-settings").addEventListener("click", () => {
    localStorage.setItem("atr_key", keyEl.value.trim());
    localStorage.setItem("atr_proxy", proxyEl.value.trim());
    localStorage.setItem("atr_gh_token", ghTokenEl.value.trim());
    localStorage.setItem("atr_gh_repo", ghRepoEl.value.trim());
    const confirm = document.getElementById("save-confirm");
    confirm.classList.remove("hidden");
    setTimeout(() => confirm.classList.add("hidden"), 2000);
  });

  // â”€â”€ Airtable API via proxy â”€â”€
  async function airtableGet(path, apiKey, proxyUrl) {
    const targetUrl = `https://api.airtable.com/v0${path}`;
    const res = await fetch(proxyUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${apiKey}`,
        "X-Airtable-Target-Url": targetUrl,
        "X-Airtable-Method": "GET",
      },
    });
    const data = await res.json().catch(() => null);
    if (!res.ok) throw new Error(data?.error?.message || `HTTP ${res.status}`);
    return data;
  }

  // â”€â”€ Schema processing (same logic as CLI export-schema.js) â”€â”€
  function classifyField(field) {
    if (NON_CREATABLE_TYPES.has(field.type)) return "manual";
    if (AUTO_SYSTEM_TYPES.has(field.type)) return "autoSystem";
    if (field.type === LINK_TYPE) {
      return field.options?.isReversed ? "inverseLink" : "link";
    }
    return "creatable";
  }

  function capitalize(str) { return str.charAt(0).toUpperCase() + str.slice(1); }

  function buildManualInstructions(field) {
    const typeLabel = field.type === "multipleLookupValues" ? "Lookup" : capitalize(field.type);
    let configSummary = "";

    switch (field.type) {
      case "formula":
        configSummary = field.options?.formula
          ? `Formula: ${field.options.formula}`
          : "Formula: (not available â€” check the original base)";
        break;
      case "rollup":
        configSummary = [
          field.options?.fieldIdInLinkedTable ? `Summarize field: ${field.options.fieldIdInLinkedTable}` : null,
          field.options?.recordLinkFieldId ? `From linked record field: ${field.options.recordLinkFieldId}` : null,
          field.options?.result?.formula ? `Aggregation: ${field.options.result.formula}` : null,
        ].filter(Boolean).join("\n");
        if (!configSummary) configSummary = "(check the original base for rollup configuration)";
        break;
      case "multipleLookupValues":
        configSummary = [
          field.options?.fieldIdInLinkedTable ? `Lookup field: ${field.options.fieldIdInLinkedTable}` : null,
          field.options?.recordLinkFieldId ? `From linked record field: ${field.options.recordLinkFieldId}` : null,
        ].filter(Boolean).join("\n");
        if (!configSummary) configSummary = "(check the original base for lookup configuration)";
        break;
      case "count":
        configSummary = field.options?.recordLinkFieldId
          ? `Count records from linked field: ${field.options.recordLinkFieldId}`
          : "(check the original base for count configuration)";
        break;
      default:
        configSummary = "(check the original base for configuration)";
    }

    const description = `âš ï¸ MANUAL SETUP REQUIRED â€” ${typeLabel}: ${configSummary.split("\\n")[0]}`;
    const cellInstructions = [
      `âš ï¸ MANUAL SETUP REQUIRED`, ``,
      `Field type: ${typeLabel} (currently Long Text â€” you must change it)`, ``,
      configSummary, ``,
      `Steps:`,
      `1. Click this field's column header`,
      `2. Select "Customize field type"`,
      `3. Change the type from "Long text" to "${typeLabel}"`,
      `4. Configure using the information above`,
      `5. Click "Save"`,
      `6. Delete this instruction row when you're done with ALL fields in this table`,
    ].join("\n");

    return { description, cellInstructions };
  }

  function processSchema(rawSchema, baseName) {
    const tables = rawSchema.tables.map((table) => {
      const creatableFields = [], linkFields = [], manualFields = [], inverseLinkFields = [], autoSystemFields = [];

      for (const field of table.fields) {
        const category = classifyField(field);
        const cleanField = { originalId: field.id, name: field.name, type: field.type, description: field.description || "" };

        if (field.options) {
          cleanField.options = JSON.parse(JSON.stringify(field.options));
          if (cleanField.options.choices) {
            cleanField.options.choices = cleanField.options.choices.map(({ name, color }) => {
              const c = { name }; if (color) c.color = color; return c;
            });
          }
        }

        switch (category) {
          case "creatable": creatableFields.push(cleanField); break;
          case "link":
            cleanField.linkedTableId = field.options?.linkedTableId;
            cleanField.prefersSingleRecordLink = field.options?.prefersSingleRecordLink || false;
            linkFields.push(cleanField); break;
          case "manual": {
            const instructions = buildManualInstructions(field);
            cleanField.manualType = field.type === "multipleLookupValues" ? "Lookup" : capitalize(field.type);
            cleanField.manualDescription = instructions.description;
            cleanField.manualCellInstructions = instructions.cellInstructions;
            cleanField.originalOptions = field.options || {};
            manualFields.push(cleanField); break;
          }
          case "autoSystem": autoSystemFields.push(cleanField); break;
          case "inverseLink": inverseLinkFields.push(cleanField); break;
        }
      }

      return {
        originalId: table.id, name: table.name, description: table.description || "",
        primaryFieldId: table.primaryFieldId,
        creatableFields, linkFields, manualFields, autoSystemFields, inverseLinkFields,
      };
    });

    // Resolve linked table names
    const tableIdToName = {};
    for (const t of tables) tableIdToName[t.originalId] = t.name;
    for (const t of tables) {
      for (const lf of t.linkFields) {
        lf.linkedTableName = tableIdToName[lf.linkedTableId] || lf.linkedTableId;
      }
      // Resolve field references in manual field instructions
      for (const mf of t.manualFields) {
        if (mf.originalOptions?.recordLinkFieldId) {
          for (const t2 of tables) {
            for (const f of [...t2.creatableFields, ...t2.linkFields]) {
              if (f.originalId === mf.originalOptions.recordLinkFieldId) {
                mf.manualCellInstructions = mf.manualCellInstructions.replace(mf.originalOptions.recordLinkFieldId, `"${f.name}" field`);
                mf.manualDescription = mf.manualDescription.replace(mf.originalOptions.recordLinkFieldId, `"${f.name}" field`);
              }
            }
          }
        }
        if (mf.originalOptions?.fieldIdInLinkedTable) {
          for (const t2 of tables) {
            for (const f of [...t2.linkFields, ...t2.inverseLinkFields]) {
              if (f.originalId === mf.originalOptions?.recordLinkFieldId && f.linkedTableId) {
                const linkedTable = tables.find((tt) => tt.originalId === f.linkedTableId);
                if (linkedTable) {
                  const linkedField = [...linkedTable.creatableFields, ...linkedTable.linkFields, ...linkedTable.manualFields]
                    .find((ff) => ff.originalId === mf.originalOptions.fieldIdInLinkedTable);
                  if (linkedField) {
                    mf.manualCellInstructions = mf.manualCellInstructions.replace(mf.originalOptions.fieldIdInLinkedTable, `"${linkedField.name}" in "${linkedTable.name}"`);
                    mf.manualDescription = mf.manualDescription.replace(mf.originalOptions.fieldIdInLinkedTable, `"${linkedField.name}" in "${linkedTable.name}"`);
                  }
                }
              }
            }
          }
        }
      }
    }

    return { name: baseName || "Airtable Base", exportedAt: new Date().toISOString(), tableCount: tables.length, tables };
  }

  // â”€â”€ Load the install.html template â”€â”€
  // We fetch the template from the same directory, or use an embedded fallback
  let INSTALL_TEMPLATE = null;

  async function loadTemplate() {
    if (INSTALL_TEMPLATE) return INSTALL_TEMPLATE;
    try {
      // Try to load from relative path (works when hosted together)
      const res = await fetch("template/install.html");
      if (res.ok) {
        INSTALL_TEMPLATE = await res.text();
        return INSTALL_TEMPLATE;
      }
    } catch (e) {}
    throw new Error("Could not load template/install.html. Make sure admin.html is in the project root directory.");
  }

  function generateHtml(template, schema, proxyUrl) {
    let html = template.replace("__SCHEMA_DATA_PLACEHOLDER__", JSON.stringify(schema));
    html = html.replace("__PROXY_URL_PLACEHOLDER__", proxyUrl);
    return html;
  }

  function sanitizeFilename(name) {
    return name.replace(/[^a-zA-Z0-9_\- ]/g, "").replace(/\s+/g, "-").toLowerCase();
  }

  // â”€â”€ Generate button handler â”€â”€
  let generatedHtml = null;
  let generatedFilename = null;

  document.getElementById("generate-btn").addEventListener("click", async () => {
    const apiKey = keyEl.value.trim();
    const proxyUrl = proxyEl.value.trim();
    const baseId = document.getElementById("gen-base").value.trim();
    const courseName = document.getElementById("gen-name").value.trim();

    if (!apiKey) { alert("Enter your API key in Settings first."); return; }
    if (!proxyUrl) { alert("Enter your CORS Proxy URL in Settings first."); return; }
    if (!baseId || !baseId.startsWith("app")) { alert("Enter a valid Base ID (starts with 'app')."); return; }
    if (!courseName) { alert("Enter a Course / Base Name."); return; }

    // Save settings automatically
    localStorage.setItem("atr_key", apiKey);
    localStorage.setItem("atr_proxy", proxyUrl);

    const btn = document.getElementById("generate-btn");
    btn.disabled = true;
    btn.textContent = "Fetching...";
    document.getElementById("status-section").classList.remove("hidden");
    document.getElementById("result-section").classList.add("hidden");
    document.getElementById("error-section").classList.add("hidden");
    document.getElementById("deploy-status").classList.add("hidden");
    document.getElementById("deploy-result").classList.add("hidden");
    document.getElementById("status-text").textContent = "Fetching schema from Airtable...";

    try {
      // Step 1: Fetch schema via proxy
      const rawSchema = await airtableGet(`/meta/bases/${baseId}/tables`, apiKey, proxyUrl);
      document.getElementById("status-text").textContent = `Found ${rawSchema.tables.length} table(s). Processing...`;

      // Step 2: Process schema
      const processed = processSchema(rawSchema, courseName);

      // Step 3: Load template and generate HTML
      document.getElementById("status-text").textContent = "Generating install page...";
      const template = await loadTemplate();
      generatedHtml = generateHtml(template, processed, proxyUrl);
      generatedFilename = `install-${sanitizeFilename(courseName)}.html`;

      // Step 4: Show result
      document.getElementById("status-section").classList.add("hidden");
      document.getElementById("result-section").classList.remove("hidden");

      let summaryHtml = `<p><strong>${courseName}</strong> â€” ${processed.tableCount} table(s)</p><ul class="mt-2 space-y-1">`;
      for (const t of processed.tables) {
        const parts = [`${t.creatableFields.length} fields`];
        if (t.linkFields.length > 0) parts.push(`${t.linkFields.length} link(s)`);
        if (t.manualFields.length > 0) parts.push(`${t.manualFields.length} manual-setup`);
        if (t.autoSystemFields.length > 0) parts.push(`${t.autoSystemFields.length} auto-system`);
        summaryHtml += `<li>${t.name}: ${parts.join(", ")}</li>`;
      }
      summaryHtml += "</ul>";
      summaryHtml += `<p class="mt-2">Filename: <code class="bg-green-100 px-1 rounded">${generatedFilename}</code></p>`;
      document.getElementById("schema-summary").innerHTML = summaryHtml;

    } catch (err) {
      document.getElementById("status-section").classList.add("hidden");
      document.getElementById("error-section").classList.remove("hidden");
      document.getElementById("error-text").textContent = err.message;
    }

    btn.disabled = false;
    btn.textContent = "Fetch Schema & Generate HTML";
  });

  // â”€â”€ Download button â”€â”€
  document.getElementById("download-btn").addEventListener("click", () => {
    if (!generatedHtml) return;
    const blob = new Blob([generatedHtml], { type: "text/html" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = generatedFilename;
    a.click();
    URL.revokeObjectURL(url);
  });

  // â”€â”€ Deploy to GitHub Pages â”€â”€
  async function deployToGitHubPages(htmlContent, filename, ghToken, ghRepo) {
    const [owner, repo] = ghRepo.split("/");
    if (!owner || !repo) throw new Error("Invalid repo format. Use 'owner/repo-name'.");

    const apiBase = `https://api.github.com/repos/${owner}/${repo}`;
    const headers = {
      "Authorization": `Bearer ${ghToken}`,
      "Accept": "application/vnd.github+json",
      "Content-Type": "application/json",
    };

    // 1. Get the current gh-pages branch ref to find the latest commit
    const refRes = await fetch(`${apiBase}/git/ref/heads/gh-pages`, { headers });
    if (!refRes.ok) {
      if (refRes.status === 404) throw new Error("Branch 'gh-pages' not found. Run ./deploy.sh once first to create it, or create it on GitHub.");
      throw new Error(`GitHub API error: ${refRes.status}`);
    }
    const refData = await refRes.json();
    const latestCommitSha = refData.object.sha;

    // 2. Get the tree of the latest commit
    const commitRes = await fetch(`${apiBase}/git/commits/${latestCommitSha}`, { headers });
    const commitData = await commitRes.json();
    const baseTreeSha = commitData.tree.sha;

    // 3. Create a blob with the HTML content
    const blobRes = await fetch(`${apiBase}/git/blobs`, {
      method: "POST", headers,
      body: JSON.stringify({ content: htmlContent, encoding: "utf-8" }),
    });
    const blobData = await blobRes.json();

    // 4. Also build a simple index.html listing all install files
    // First, get the current tree to find existing install files
    const treeRes = await fetch(`${apiBase}/git/trees/${baseTreeSha}`, { headers });
    const treeData = await treeRes.json();
    const existingFiles = treeData.tree
      .filter(item => item.path.startsWith("install-") && item.path.endsWith(".html"))
      .map(item => item.path);
    // Add the new file if not already there
    if (!existingFiles.includes(filename)) {
      existingFiles.push(filename);
    }
    existingFiles.sort();

    // Build index HTML
    const indexLinks = existingFiles.map(f => {
      const name = f.replace("install-", "").replace(".html", "").replace(/-/g, " ");
      const displayName = name.replace(/\b\w/g, c => c.toUpperCase());
      return `    <a href="${f}" class="block p-4 bg-white rounded-lg shadow hover:shadow-md transition border border-gray-200 text-blue-600 hover:text-blue-800 font-medium">${displayName}</a>`;
    }).join("\n");

    const indexHtml = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Airtable Base Replicator â€” Install Pages</title>
  <script src="https://cdn.tailwindcss.com"><\/script>
</head>
<body class="bg-gray-50 min-h-screen flex items-center justify-center p-8">
  <div class="max-w-lg w-full">
    <h1 class="text-2xl font-bold text-gray-800 mb-2">ðŸ“‹ Install Pages</h1>
    <p class="text-gray-500 mb-6">Click a link to open the installer for that course base.</p>
    <div class="space-y-3">
${indexLinks}
    </div>
  </div>
</body>
</html>`;

    const indexBlobRes = await fetch(`${apiBase}/git/blobs`, {
      method: "POST", headers,
      body: JSON.stringify({ content: indexHtml, encoding: "utf-8" }),
    });
    const indexBlobData = await indexBlobRes.json();

    // 5. Create a new tree with both files
    const newTreeRes = await fetch(`${apiBase}/git/trees`, {
      method: "POST", headers,
      body: JSON.stringify({
        base_tree: baseTreeSha,
        tree: [
          { path: filename, mode: "100644", type: "blob", sha: blobData.sha },
          { path: "index.html", mode: "100644", type: "blob", sha: indexBlobData.sha },
        ],
      }),
    });
    const newTreeData = await newTreeRes.json();

    // 6. Create a new commit
    const newCommitRes = await fetch(`${apiBase}/git/commits`, {
      method: "POST", headers,
      body: JSON.stringify({
        message: `Deploy ${filename} â€” ${new Date().toISOString().slice(0, 16)}`,
        tree: newTreeData.sha,
        parents: [latestCommitSha],
      }),
    });
    const newCommitData = await newCommitRes.json();

    // 7. Update the gh-pages branch ref
    await fetch(`${apiBase}/git/refs/heads/gh-pages`, {
      method: "PATCH", headers,
      body: JSON.stringify({ sha: newCommitData.sha }),
    });

    // Return the Pages URL
    return `https://${owner}.github.io/${repo}/${filename}`;
  }

  document.getElementById("deploy-btn").addEventListener("click", async () => {
    if (!generatedHtml || !generatedFilename) return;

    const ghToken = ghTokenEl.value.trim();
    const ghRepo = ghRepoEl.value.trim();

    if (!ghToken) { alert("Enter your GitHub Token in Settings first."); return; }
    if (!ghRepo || !ghRepo.includes("/")) { alert("Enter your GitHub Repo in Settings (format: owner/repo-name)."); return; }

    // Save settings automatically
    localStorage.setItem("atr_gh_token", ghToken);
    localStorage.setItem("atr_gh_repo", ghRepo);

    const btn = document.getElementById("deploy-btn");
    btn.disabled = true;
    btn.innerHTML = '<div class="spinner" style="width:16px;height:16px;border-width:2px;"></div> Deploying...';
    document.getElementById("deploy-status").classList.remove("hidden");
    document.getElementById("deploy-result").classList.add("hidden");
    document.getElementById("error-section").classList.add("hidden");

    try {
      const studentUrl = await deployToGitHubPages(generatedHtml, generatedFilename, ghToken, ghRepo);

      document.getElementById("deploy-status").classList.add("hidden");
      document.getElementById("deploy-result").classList.remove("hidden");
      document.getElementById("student-link").value = studentUrl;

    } catch (err) {
      document.getElementById("deploy-status").classList.add("hidden");
      document.getElementById("error-section").classList.remove("hidden");
      document.getElementById("error-text").textContent = `Deploy failed: ${err.message}`;
    }

    btn.disabled = false;
    btn.innerHTML = 'ðŸš€ Deploy to GitHub Pages';
  });

  // â”€â”€ Copy link button â”€â”€
  document.getElementById("copy-link-btn").addEventListener("click", () => {
    const linkEl = document.getElementById("student-link");
    linkEl.select();
    navigator.clipboard.writeText(linkEl.value).then(() => {
      const btn = document.getElementById("copy-link-btn");
      btn.textContent = "âœ… Copied!";
      setTimeout(() => { btn.textContent = "ðŸ“‹ Copy"; }, 2000);
    });
  });

})();
</script>
</body>
</html>
